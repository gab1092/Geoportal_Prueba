<!DOCTYPE html>
<html>
<head>
    <title>Muestra</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.graticule@0.2.1/L.Graticule.css" />

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil@latest/src/leaflet.geometryutil.js"></script>
    <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script> 
    <script src="https://unpkg.com/leaflet.graticule@0.2.1/L.Graticule.js"></script>

    <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
    <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script> 
    
    <style>
        /* --- ESTILOS GENERALES Y FUENTE --- */
        html, body, #map { 
            height: 100%; 
            width: 100%; 
            margin: 0; 
            padding: 0; 
            background-color: #f4f4f4; 
            font-family: 'Roboto', sans-serif;
        }

        /* --- PANELES Y CONTROLES CON ESTILO MODERNO --- */
        .leaflet-bar, .info, .leaflet-control-layers {
            background-color: white;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ddd;
            transition: box-shadow 0.3s ease;
        }
        .leaflet-bar a, .leaflet-bar a:hover {
            border-radius: 6px;
        }
        .custom-control {
             padding: 8px 12px;
             cursor: pointer;
             font-size: 14px;
             font-weight: 500;
             transition: all 0.2s ease-in-out;
        }
        .custom-control:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0,0,0,0.1);
        }
        
        /* --- PANEL DE INFORMACIÓN Y LEYENDA (MÁS VERTICAL) --- */
        .info { 
            padding: 10px 15px; 
            max-height: 70vh;
            overflow-y: auto; 
            max-width: 280px;
        }
        .info h4 { 
            margin: 0 0 10px; 
            color: #333; 
            font-size: 16px;
            font-weight: 700;
            cursor: pointer; 
            user-select: none; 
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        .info h4::after { content: ' ▼'; font-size: 12px; float: right; color: #999; }
        .info.collapsed { max-height: 42px; overflow: hidden; }
        .info.collapsed h4::after { content: ' ►'; }
        
        .legend i { 
            width: 18px; 
            height: 18px; 
            float: left; 
            margin-right: 8px; 
            opacity: 0.9;
            border-radius: 4px;
        }
        .config-options { 
            margin-top: 10px; 
            padding-top: 10px; 
        }
        .info label { 
            font-weight: 500; 
            color: #555; 
            font-size: 13px;
            display: block;
            margin-top: 10px;
        }
        .info select, .info input {
            width: 100%;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #ccc;
            padding: 5px;
            margin-top: 5px;
        }
        .info input[type="color"] {
            height: 35px;
        }

        /* --- LISTA DE CAPAS --- */
        .layer-list li {
            border-radius: 4px;
            margin-bottom: 5px;
            transition: background-color 0.2s;
        }
        .layer-list li.active { 
            font-weight: bold; 
            background-color: #e0f0ff; 
            border-left: 4px solid #007bff;
            padding-left: 10px;
        }
        
        /* --- TÍTULO Y OTROS ELEMENTOS --- */
        #map-title {
            position: absolute;
            top: 15px;
            left: 70px;
            z-index: 800;
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: 700;
            color: #333;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .leaflet-top.leaflet-left .custom-control + .custom-control {
            margin-top: 10px;
        }

        /* --- CONTROL DE ATRIBUCIÓN PERSONALIZADO --- */
        .custom-attribution {
            position: absolute;
            bottom: 0;
            right: 0;
            padding: 3px 8px;
            background: rgba(255, 255, 255, 0.8);
            color: #333;
            font-size: 12px;
            z-index: 800;
            border-top-left-radius: 8px;
        }
    </style>
</head>
<body>

<div id="map-title">Geoportal de muestra</div>
<div id="map"></div>
<div class="custom-attribution">Hecho con <a href="https://leafletjs.com/" target="_blank">Leaflet</a> | Elaborado por GRC | Uso exclusivo con fines académicos</div>


<script>
    // --- INICIALIZACIÓN DEL MAPA ---
    const map = L.map('map', { 
        attributionControl: false, 
        preferCanvas: true 
    }).setView([24.5, -99.5], 5); 

    // --- VARIABLES GLOBALES ---
    let currentActiveLayer = null;
    let orderedLayers = [];
    
    // --- CAPAS BASE DE ESRI ---
    const oceanBasemap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri'
    });
    const streets = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
    });
    const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    });

    const baseMaps = { "Océano": oceanBasemap, "Calles": streets, "Satélite": satellite };
    oceanBasemap.addTo(map); // Mapa por defecto
    
    // --- CONTROL DE CAPAS ---
    const layerControl = L.control.layers(baseMaps, {}, { 
        collapsed: true,
        position: 'topright' 
    }).addTo(map);

    // --- CONTROL DE ATRIBUCIÓN ESTÁNDAR ---
    L.control.attribution({ 
        position: 'bottomleft', 
        prefix: false 
    }).addTo(map);

    // --- AÑADIR RETÍCULA DE COORDENADAS ---
    L.graticule().addTo(map);
    
    const infoControl = L.control();
    const legendControl = L.control({position: 'bottomright'});
    let sortableInstance = null;
    let drawnItemsHistory = []; 

    const sequentialPalettes = { 'YlOrRd': ['#FFFFE5','#FFF7BC','#FEE391','#FEC44F','#FE9929','#EC7014','#CC4C02','#993404','#662506','#4C1B03'], 'Blues': ['#F7FBFF','#E3EEF9','#CFE1F2','#B5D4E9','#AC7E1','#7FB9D9','#64ABD1','#4BA0C9','#3294C1','#0884B9'], 'Greens': ['#F7F7F7','#E5F5E0','#C7E9C0','#A1D99B','#74C476','#41AB5D','#238B45','#006D2C','#00441B','#002B12'], 'Reds': ['#FFF5F0','#FEE0D2','#FCBBA1','#FC9272','#FB6A4A','#EF3B2C','#CB181D','#A50F15','#67000D','#4A0008'] };
    const categoricalPalettes = { 'Paired': ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928'], 'Accent': ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666'], 'Set1': ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'] };

    function getColor(value, grades, paletteName) { if (value === undefined || value === null) return '#CCCCCC'; const palette = sequentialPalettes[paletteName]; for (let i = grades.length - 2; i >= 0; i--) { if (value > grades[i]) { return palette[i % palette.length]; } } if (value === grades[0]) return palette[0]; return '#CCCCCC'; }
    function updateVisualization(layer) { 
        if (!layer) return; 
        const config = layer.options.config; 
        const isPointLayer = layer.options.pointLayer;
        
        if (config.displayMode === 'simple') { 
            let simpleStyle = { weight: 2, color: config.simpleOutlineColor, fillColor: config.simpleFillColor }; 
            switch(config.simpleRenderMode) { 
                case 'both': simpleStyle.stroke = true; simpleStyle.fill = true; simpleStyle.fillOpacity = 0.6; break; 
                case 'fill': simpleStyle.stroke = false; simpleStyle.fill = true; simpleStyle.fillOpacity = 0.6; break; 
                case 'outline': simpleStyle.stroke = true; simpleStyle.fill = false; break; 
            } 
            
            if (isPointLayer) {
                layer.eachLayer(function(l) {
                    if (l instanceof L.CircleMarker) {
                        l.setStyle({ fillColor: config.simpleFillColor, color: config.simpleOutlineColor, fillOpacity: 0.8, radius: 8 });
                    }
                });
            } else {
                layer.setStyle(simpleStyle); 
            }
            if (layer === currentActiveLayer) legendControl.update(null); 
            return; 
        } 
        
        if (config.displayMode === 'classified') { 
            const values = layer.toGeoJSON().features.map(f => f.properties[config.activeVariable]).filter(v => v !== null && typeof v === 'number' && isFinite(v)); 
            const uniqueValues = [...new Set(values)]; 
            if (uniqueValues.length < 2) { 
                config.numericStats[config.activeVariable].grades = []; 
            } else { 
                const classCount = Math.min(uniqueValues.length, config.numClasses, sequentialPalettes[config.activePalette].length); 
                config.numericStats[config.activeVariable].grades = ss.jenks(values, classCount); 
            } 
        } 
        
        if (config.displayMode === 'categorical') { 
            const values = layer.toGeoJSON().features.map(f => f.properties[config.activeCategoricalVariable]); 
            const uniqueValues = [...new Set(values)].sort(); 
            config.categoricalMap = {}; 
            const palette = categoricalPalettes[config.activeCategoricalPalette]; 
            uniqueValues.forEach((value, index) => { config.categoricalMap[value] = palette[index % palette.length]; }); 
        } 
        
        const getDynamicStyle = function(feature) { 
            const currentConfig = this.options.config; 
            if (currentConfig.displayMode === 'classified') { 
                const value = feature.properties[currentConfig.activeVariable]; 
                const grades = currentConfig.numericStats[currentConfig.activeVariable].grades; 
                return { fillColor: getColor(value, grades, currentConfig.activePalette), weight: 1, opacity: 1, color: 'white', fillOpacity: 0.8 }; 
            } 
            if (currentConfig.displayMode === 'categorical') { 
                const value = feature.properties[currentConfig.activeCategoricalVariable]; 
                const color = currentConfig.categoricalMap[value] || '#CCCCCC'; 
                return { fillColor: color, weight: 1, opacity: 1, color: 'white', fillOpacity: 0.8 }; 
            } 
            return {};
        }.bind({options: {config: layer.options.config}});

        if (isPointLayer) {
             layer.eachLayer(function(l) {
                if (l instanceof L.CircleMarker) {
                    const style = getDynamicStyle(l.feature);
                    l.setStyle({ fillColor: style.fillColor, color: style.color, fillOpacity: style.fillOpacity, radius: 8 });
                }
            });
        } else {
            layer.setStyle(getDynamicStyle); 
        }
        
        if (layer === currentActiveLayer) { 
            legendControl.update(layer); 
        } 
    }

    function processData(geojson, name) { 
        const numericProperties = [], stringProperties = [], numericStats = {}; 
        let hasPoints = false;
        
        if (geojson.features && geojson.features.length > 0) { 
            const firstProps = geojson.features[0].properties; 
            for (const key in firstProps) { 
                if (typeof firstProps[key] === 'number') { 
                    numericProperties.push(key); 
                    numericStats[key] = {}; 
                } else if (typeof firstProps[key] === 'string') { 
                    stringProperties.push(key); 
                } 
            }
            hasPoints = geojson.features.some(f => f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint');
        } 

        const defaultMode = numericProperties.length > 0 ? 'classified' : (stringProperties.length > 0 ? 'categorical' : 'simple'); 
        const layerConfig = { 
            name, 
            numericProperties, 
            stringProperties, 
            numericStats, 
            activeVariable: numericProperties[0] || null, 
            activeCategoricalVariable: stringProperties[0] || null, 
            numClasses: 7, 
            activePalette: 'YlOrRd', 
            activeCategoricalPalette: 'Paired', 
            displayMode: defaultMode, 
            simpleRenderMode: 'both', 
            simpleFillColor: '#3388ff',
            simpleOutlineColor: '#ffffff'
        }; 
        
        const geoJSONOptions = {
            config: layerConfig,
            style: function(feature) {
                return { color: "#3388ff", weight: 2, fillOpacity: 0.6 };
            },
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, {
                    radius: 8,
                    fillColor: layerConfig.simpleFillColor,
                    color: layerConfig.simpleOutlineColor,
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });
            }
        };

        const newLayer = L.geoJSON(geojson, geoJSONOptions);
        
        newLayer.options.pointLayer = hasPoints; 
        newLayer.addTo(map);

        newLayer.eachLayer(layer => { 
            let popupContent = '<table>'; 
            for (const key in layer.feature.properties) { 
                popupContent += `<tr><td><strong>${key}</strong></td><td>${layer.feature.properties[key]}</td></tr>`; 
            } 
            popupContent += '</table>'; 
            layer.bindPopup(popupContent, { maxHeight: 200, minWidth: 200 }); 
        }); 
        
        layerControl.addOverlay(newLayer, name); 
        orderedLayers.unshift(newLayer); 
        currentActiveLayer = newLayer; 
        infoControl.update(); 
        updateVisualization(currentActiveLayer); 
        applyLayerOrder(); 
    }
    infoControl.onAdd = function (map) { this._div = L.DomUtil.create('div', 'info'); L.DomEvent.disableClickPropagation(this._div); L.DomEvent.on(this._div, 'click', function(e) { if (e.target.tagName === 'H4') { this._div.classList.toggle('collapsed'); } }, this); this.update(); return this._div; };
    infoControl.update = function () { let htmlContent = '<h4>Configuración</h4>'; if (orderedLayers.length === 0) { htmlContent += '<p>Cargue un archivo para empezar.</p>'; this._div.innerHTML = htmlContent; return; } htmlContent += `<label>Capas (arrastra para ordenar):</label><ul id="layer-list" class="layer-list">`; orderedLayers.forEach(layer => { const layerId = L.stamp(layer); const isActiveClass = (currentActiveLayer && layerId === L.stamp(currentActiveLayer)) ? 'active' : ''; htmlContent += `<li class="${isActiveClass}" data-layer-id="${layerId}">${layer.options.config.name}</li>`; }); htmlContent += `</ul>`; if (currentActiveLayer) { const config = currentActiveLayer.options.config; htmlContent += `<div class="config-options">`; htmlContent += `<label for="mode-selector">Modo de Visualización:</label><select id="mode-selector">`; htmlContent += `<option value="simple" ${config.displayMode === 'simple' ? 'selected' : ''}>Estilo Simple</option>`; if (config.numericProperties.length > 0) { htmlContent += `<option value="classified" ${config.displayMode === 'classified' ? 'selected' : ''}>Clasificado (Números)</option>`; } if (config.stringProperties.length > 0) { htmlContent += `<option value="categorical" ${config.displayMode === 'categorical' ? 'selected' : ''}>Por Categorías (Texto)</option>`; } htmlContent += `</select>`; if (config.displayMode === 'simple') { htmlContent += `<label for="render-mode-selector">Mostrar:</label><select id="render-mode-selector"><option value="both" ${config.simpleRenderMode === 'both' ? 'selected' : ''}>Relleno y Contorno</option><option value="fill" ${config.simpleRenderMode === 'fill' ? 'selected' : ''}>Solo Relleno</option><option value="outline" ${config.simpleRenderMode === 'outline' ? 'selected' : ''}>Solo Contorno</option></select>`; htmlContent += `<label>Relleno:</label><input type="color" id="fill-color-picker" value="${config.simpleFillColor}"><label>Contorno:</label><input type="color" id="outline-color-picker" value="${config.simpleOutlineColor}">`; } if (config.displayMode === 'classified') { htmlContent += `<label for="variable-selector">Variable Numérica:</label><select id="variable-selector">`; config.numericProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeVariable ? 'selected' : ''}>${prop}</option>`; }); htmlContent += `</select>`; htmlContent += `<label for="classes-input">Clases:</label><input type="number" id="classes-input" value="${config.numClasses}" min="2" max="10">`; htmlContent += `<label for="palette-selector">Paleta:</label><select id="palette-selector">`; for (const key in sequentialPalettes) { htmlContent += `<option value="${key}" ${key === config.activePalette ? 'selected' : ''}>${key}</option>`; } htmlContent += `</select>`; } if (config.displayMode === 'categorical') { htmlContent += `<label for="categorical-variable-selector">Variable de Texto:</label><select id="categorical-variable-selector">`; config.stringProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeCategoricalVariable ? 'selected' : ''}>${prop}</option>`; }); htmlContent += `</select>`; htmlContent += `<label for="categorical-palette-selector">Paleta:</label><select id="categorical-palette-selector">`; for (const key in categoricalPalettes) { htmlContent += `<option value="${key}" ${key === config.activeCategoricalPalette ? 'selected' : ''}>${key}</option>`; } htmlContent += `</select>`; } htmlContent += `</div>`; } this._div.innerHTML = htmlContent; const layerListEl = this._div.querySelector('#layer-list'); if (layerListEl) { sortableInstance = new Sortable(layerListEl, { animation: 150, onEnd: (evt) => { const movedItem = orderedLayers.splice(evt.oldIndex, 1)[0]; orderedLayers.splice(evt.newIndex, 0, movedItem); applyLayerOrder(); infoControl.update(); } }); } this._div.querySelectorAll('#layer-list li').forEach(item => { item.addEventListener('click', () => { const layerId = parseInt(item.dataset.layerId, 10); currentActiveLayer = orderedLayers.find(l => L.stamp(l) === layerId); this.update(); legendControl.update(currentActiveLayer); }); }); if (currentActiveLayer) { const config = currentActiveLayer.options.config; const modeSelector = this._div.querySelector('#mode-selector'); if (modeSelector) { modeSelector.onchange = (e) => { config.displayMode = e.target.value; this.update(); updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'simple') { this._div.querySelector('#render-mode-selector').onchange = (e) => { config.simpleRenderMode = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#fill-color-picker').onchange = (e) => { config.simpleFillColor = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#outline-color-picker').onchange = (e) => { config.simpleOutlineColor = e.target.value; updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'classified') { this._div.querySelector('#variable-selector').onchange = (e) => { config.activeVariable = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#classes-input').onchange = (e) => { let val = parseInt(e.target.value, 10); if (val >= 2 && val <= 10) { config.numClasses = val; updateVisualization(currentActiveLayer); } else { e.target.value = config.numClasses; } }; this._div.querySelector('#palette-selector').onchange = (e) => { config.activePalette = e.target.value; updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'categorical') { this._div.querySelector('#categorical-variable-selector').onchange = (e) => { config.activeCategoricalVariable = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#categorical-palette-selector').onchange = (e) => { config.activeCategoricalPalette = e.target.value; updateVisualization(currentActiveLayer); }; } } };
    infoControl.addTo(map);
    legendControl.onAdd = function (map) { this._div = L.DomUtil.create('div', 'info legend'); return this._div; };
    legendControl.update = function (layer) { let content = ""; if (layer && layer.options.config.displayMode === 'classified' && layer.options.config.numericStats[layer.options.config.activeVariable].grades?.length > 1) { const config = layer.options.config; const grades = config.numericStats[config.activeVariable].grades; const palette = sequentialPalettes[config.activePalette]; let labels = ['<h4>' + config.activeVariable + '</h4>']; for (let i = 0; i < grades.length - 1; i++) { if (palette[i]) { labels.push(`<i style="background:${palette[i]}"></i> ${grades[i].toLocaleString(undefined, {maximumFractionDigits: 2})} &ndash; ${grades[i+1].toLocaleString(undefined, {maximumFractionDigits: 2})}`); } } content = labels.join('<br>'); } else if (layer && layer.options.config.displayMode === 'categorical' && layer.options.config.categoricalMap) { const config = layer.options.config; let labels = ['<h4>' + config.activeCategoricalVariable + '</h4>']; for (const value in config.categoricalMap) { labels.push(`<i style="background:${config.categoricalMap[value]}"></i> ${value}`); } content = labels.join('<br>'); } this._div.innerHTML = content; };
    legendControl.addTo(map);
    function applyLayerOrder() { orderedLayers.forEach(layer => layer.bringToFront()); }
    map.on('overlayadd', e => { const index = orderedLayers.findIndex(l => L.stamp(l) === L.stamp(e.layer)); if (index === -1) { orderedLayers.unshift(e.layer); } if (!currentActiveLayer) { currentActiveLayer = e.layer; } applyLayerOrder(); infoControl.update(); legendControl.update(currentActiveLayer); });
    map.on('overlayremove', e => { const layerIdToRemove = L.stamp(e.layer); orderedLayers = orderedLayers.filter(layer => L.stamp(layer) !== layerIdToRemove); if (e.layer === currentActiveLayer) { currentActiveLayer = orderedLayers.length > 0 ? orderedLayers[0] : null; } infoControl.update(); legendControl.update(currentActiveLayer); });
    function handleUploadedFile(file) {
        if (!file) return;
        const extension = file.name.split('.').pop().toLowerCase();
        const reader = new FileReader();

        const loadingMessage = L.DomUtil.create('div', 'loading-indicator', map.getContainer());
        loadingMessage.innerText = `Cargando ${file.name}...`;

        reader.onload = function(event) {
            try {
                if (extension === 'zip') {
                    shp(event.target.result).then(function(geojson){
                        if (Array.isArray(geojson)) {
                            geojson.forEach(featureCollection => {
                                processData(featureCollection, featureCollection.name || file.name);
                            });
                        } else {
                            processData(geojson, file.name);
                        }
                        map.getContainer().removeChild(loadingMessage);
                    }).catch(err => {
                        alert("Error procesando Shapefile: " + err.message);
                        map.getContainer().removeChild(loadingMessage);
                    });
                } else if (extension === 'geojson' || extension === 'json') {
                    processData(JSON.parse(event.target.result), file.name);
                    map.getContainer().removeChild(loadingMessage);
                }
            } catch (err) {
                alert("Error procesando el archivo: " + err.message);
                map.getContainer().removeChild(loadingMessage);
            }
        };
        reader.onerror = function() {
            alert("Error al leer el archivo.");
            map.getContainer().removeChild(loadingMessage);
        };

        if (extension === 'zip') {
            reader.readAsArrayBuffer(file);
        } else {
            reader.readAsText(file);
        }
    }
    
    L.Control.Custom = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-control');
            container.innerText = 'Cargar Archivo(s)';
            
            const fileInput = L.DomUtil.create('input');
            fileInput.type = 'file';
            fileInput.accept = ".geojson,.json,.zip";
            fileInput.multiple = true;
            fileInput.style.display = 'none';

            container.appendChild(fileInput);

            fileInput.onchange = (e) => {
                if (!e.target.files) return;
                for (const file of e.target.files) {
                    handleUploadedFile(file);
                }
                e.target.value = '';
            };
            
            L.DomEvent.on(container, 'click', (e) => {
                L.DomEvent.stopPropagation(e);
                fileInput.click();
            });
            return container;
        }
    });
    new L.Control.Custom({ position: 'topleft' }).addTo(map);

    function exportMap() {
        const controlsToHide = document.querySelectorAll(
            '.leaflet-control-container > .leaflet-top, ' +
            '.leaflet-control-container > .leaflet-bottom-left, ' +
            '.info.leaflet-control:not(.legend), ' +
            '#map-title'
        );
        controlsToHide.forEach(el => el.classList.add('hide-for-export'));

        leafletImage(map, function(err, canvas) {
            controlsToHide.forEach(el => el.classList.remove('hide-for-export'));
            if (err) {
                console.error("Error al exportar el mapa:", err);
                alert("Hubo un error al exportar el mapa.");
            } else {
                const link = document.createElement('a');
                link.download = 'mapa_exportado.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
        });
    }

    L.Control.Export = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-control');
            container.innerText = 'Exportar Imagen';
            L.DomEvent.on(container, 'click', function(e) { L.DomEvent.stopPropagation(e); exportMap(); });
            return container;
        }
    });
    new L.Control.Export({ position: 'topleft' }).addTo(map);

    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
        edit: {
            featureGroup: drawnItems,
            remove: true
        },
        draw: {
            polygon: {
                allowIntersection: false,
                showArea: true
            },
            polyline: true,
            rectangle: true,
            circle: false,
            marker: false
        }
    });
    map.addControl(drawControl);

    map.on(L.Draw.Event.CREATED, function (e) {
        const layer = e.layer;
        const type = e.layerType;
        let content = '';

        if (type === 'polyline') {
            let distance = 0;
            const latlngs = layer.getLatLngs();
            for (let i = 0; i < latlngs.length - 1; i++) {
                distance += latlngs[i].distanceTo(latlngs[i+1]);
            }
            content = `Distancia: ${ (distance / 1000).toFixed(2) } km`;
        } else if (type === 'polygon' || type === 'rectangle') {
            const area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
            content = `Área: ${ (area / 10000).toFixed(2) } hectáreas`;
        }
        
        if (content) {
            layer.bindPopup(content).openPopup();
        }
        
        drawnItems.addLayer(layer);
        
        drawnItemsHistory.push(layer); 
    });

    function undoLastDrawAction() {
        if (drawnItemsHistory.length > 0) {
            const lastDrawnLayer = drawnItemsHistory.pop();
            if (drawnItems.hasLayer(lastDrawnLayer)) {
                drawnItems.removeLayer(lastDrawnLayer);
            }
        }
    }

    document.addEventListener('keydown', function(event) {
        if ((event.ctrlKey || event.metaKey) && event.key === 'z') {
            const isInputTarget = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';
            if (!isInputTarget) {
                event.preventDefault();
                undoLastDrawAction();
            }
        }
    });
</script>
</body>
</html>
