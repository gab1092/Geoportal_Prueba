<!DOCTYPE html>
<html>
<head>
    <title>Geoportal de muestra</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil@latest/src/leaflet.geometryutil.js"></script>
    <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>
    <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
    <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-blue: #007BFF;
            --light-blue: #E6F2FF;
            --dark-blue: #0056b3;
            --text-color: #333;
            --border-color: #DEE2E6;
            --background-color: #F8F9FA;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        html, body, #map {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            font-family: 'Roboto', sans-serif;
        }

        /* Estilo general para los controles y paneles de Leaflet */
        .leaflet-bar, .info {
            background-color: var(--panel-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }
        
        .leaflet-bar a, .leaflet-bar a:hover {
            border-radius: 6px;
            color: var(--primary-blue);
        }

        .custom-control {
            padding: 10px 15px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: var(--primary-blue);
        }
        .custom-control:hover {
            background-color: var(--light-blue);
            color: var(--dark-blue);
            border-color: var(--primary-blue);
        }
        .leaflet-top.leaflet-left .custom-control + .custom-control {
            margin-top: 10px;
        }

        /* Panel de configuración principal */
        .info {
            padding: 10px 15px;
            font-size: 14px;
            line-height: 1.5;
            max-height: 80vh; /* Aumentado para más contenido */
            overflow-y: auto;
        }
        .info h4 {
            margin: -10px -15px 15px -15px;
            padding: 12px 15px;
            color: var(--dark-blue);
            background-color: var(--light-blue);
            border-bottom: 1px solid var(--border-color);
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            cursor: pointer;
            user-select: none;
            font-weight: 700;
        }
        .info h4::after { content: ' ▼'; font-size: 12px; float: right; transition: transform 0.2s; }
        .info.collapsed { max-height: 50px; overflow: hidden; }
        .info.collapsed h4::after { transform: rotate(-90deg); }

        /* Leyenda */
        .legend { text-align: left; line-height: 22px; color: var(--text-color); max-height: 300px; overflow-y: auto; }
        .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); }
        .legend h4 { background: none; margin: 0 0 10px; padding: 0; color: var(--text-color); font-size: 16px; border: none; }
        
        /* Controles de formulario (select, input) */
        .info label { display: block; margin-top: 12px; margin-bottom: 4px; font-weight: 500; color: #555; font-size: 13px; }
        .info select, .info input[type="number"], .info input[type="color"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: #fff;
            box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .info select:focus, .info input[type="number"]:focus {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
            outline: none;
        }
        .info input[type="color"] { height: 38px; padding: 2px; cursor: pointer; }
        
        .config-options { border-top: 1px solid var(--border-color); margin-top: 15px; padding-top: 10px; }
        .color-picker-container { display: flex; align-items: center; justify-content: space-between; margin-top: 8px; }

        /* Lista de capas ordenable */
        .layer-list { list-style: none; padding: 0; margin: 5px 0 15px 0; }
        .layer-list li {
            background-color: #fff;
            border: 1px solid var(--border-color);
            padding: 10px;
            margin-bottom: -1px;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
        }
        .layer-list li:first-child { border-top-left-radius: 6px; border-top-right-radius: 6px; }
        .layer-list li:last-child { border-bottom-left-radius: 6px; border-bottom-right-radius: 6px; }
        .layer-list li:hover { background-color: var(--light-blue); }
        .layer-list li.active {
            font-weight: bold;
            color: var(--dark-blue);
            background-color: var(--light-blue);
            border-left: 4px solid var(--primary-blue);
            padding-left: 7px;
        }
        .layer-list li.sortable-ghost { background: #c8ebfb; opacity: 0.7; }

        /* Título del mapa */
        #map-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(44, 62, 80, 0.85); /* Azul oscuro semitransparente */
            color: #FFFFFF;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: 500;
            box-shadow: var(--shadow);
            pointer-events: none; /* Para que no interfiera con el clic en el mapa */
        }
        
        /* Indicador de carga */
        .loading-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 1000;
            font-size: 14px;
            color: var(--text-color);
            box-shadow: var(--shadow);
        }

        /* Atribución personalizada */
        .custom-attribution {
            position: absolute;
            bottom: 0;
            right: 0;
            padding: 4px 10px;
            background: var(--panel-bg);
            color: #555;
            font-size: 12px;
            z-index: 1000;
            border-top-left-radius: 8px;
        }
        .custom-attribution a { color: var(--primary-blue); text-decoration: none; }
        .custom-attribution a:hover { text-decoration: underline; }

        .hide-for-export { display: none !important; }

    </style>
</head>
<body>

<div id="map-title">Geoportal de Muestra</div>

<div id="map"></div>

<div class="custom-attribution">
    Elaborado con <a href="https://leafletjs.com/" target="_blank">Leaflet</a> | Por Gabriela Reséndiz Colorado | Fines académicos
</div>

<script>
    // El código JavaScript no necesita cambios, pero ajustamos un color por defecto
    // para que coincida con la nueva paleta de colores.
    // =========================================================================

    const map = L.map('map', { attributionControl: false, preferCanvas: true }).setView([24.5, -99.5], 5);
    
    const infoControl = L.control();
    const legendControl = L.control({position: 'bottomright'});
    let currentActiveLayer = null;
    let orderedLayers = [];
    let sortableInstance = null;
    
    let drawnItemsHistory = []; 

    const oceanBasemap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' });
    const streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'OpenStreetMap' });
    const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' });
    const baseMaps = { "Océano": oceanBasemap, "Calles": streets, "Satélite": satellite };
    const layerControl = L.control.layers(baseMaps, {}, { collapsed: true }).addTo(map);
    oceanBasemap.addTo(map);
    
    L.control.attribution({ position: 'bottomleft', prefix: false }).addTo(map);
    
    const sequentialPalettes = { 'YlOrRd': ['#FFFFE5','#FFF7BC','#FEE391','#FEC44F','#FE9929','#EC7014','#CC4C02','#993404','#662506','#4C1B03'], 'Blues': ['#F7FBFF','#DEEBF7','#C6DBEF','#9ECAE1','#6BAED6','#4292C6','#2171B5','#08519C','#08306B'], 'Greens': ['#F7F7F7','#E5F5E0','#C7E9C0','#A1D99B','#74C476','#41AB5D','#238B45','#006D2C','#00441B','#002B12'], 'Reds': ['#FFF5F0','#FEE0D2','#FCBBA1','#FC9272','#FB6A4A','#EF3B2C','#CB181D','#A50F15','#67000D','#4A0008'] };
    const categoricalPalettes = { 'Paired': ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928'], 'Accent': ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666'], 'Set1': ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'] };

    // --- FUNCIONES Y CONTROLES ---
    function getColor(value, grades, paletteName) { if (value === undefined || value === null) return '#CCCCCC'; const palette = sequentialPalettes[paletteName]; for (let i = grades.length - 2; i >= 0; i--) { if (value > grades[i]) { return palette[i % palette.length]; } } if (value === grades[0]) return palette[0]; return '#CCCCCC'; }
    function updateVisualization(layer) { 
        if (!layer) return; 
        const config = layer.options.config; 
        
        const isPointLayer = layer.options.pointLayer;
        
        if (config.displayMode === 'simple') { 
            let simpleStyle = { weight: 2, color: config.simpleOutlineColor, fillColor: config.simpleFillColor }; 
            switch(config.simpleRenderMode) { 
                case 'both': simpleStyle.stroke = true; simpleStyle.fill = true; simpleStyle.fillOpacity = 0.6; break; 
                case 'fill': simpleStyle.stroke = false; simpleStyle.fill = true; simpleStyle.fillOpacity = 0.6; break; 
                case 'outline': simpleStyle.stroke = true; simpleStyle.fill = false; break; 
            } 
            
            if (isPointLayer) {
                layer.eachLayer(function(l) {
                    if (l instanceof L.CircleMarker) {
                        l.setStyle({ fillColor: config.simpleFillColor, color: config.simpleOutlineColor, fillOpacity: 0.8, radius: 8 });
                    }
                });
            } else {
                layer.setStyle(simpleStyle); 
            }
            if (layer === currentActiveLayer) legendControl.update(null); 
            return; 
        } 
        
        if (config.displayMode === 'classified') { 
            const values = layer.toGeoJSON().features.map(f => f.properties[config.activeVariable]).filter(v => v !== null && typeof v === 'number' && isFinite(v)); 
            const uniqueValues = [...new Set(values)]; 
            if (uniqueValues.length < 2) { 
                config.numericStats[config.activeVariable].grades = []; 
            } else { 
                const classCount = Math.min(uniqueValues.length, config.numClasses, sequentialPalettes[config.activePalette].length); 
                config.numericStats[config.activeVariable].grades = ss.jenks(values, classCount); 
            } 
        } 
        
        if (config.displayMode === 'categorical') { 
            const values = layer.toGeoJSON().features.map(f => f.properties[config.activeCategoricalVariable]); 
            const uniqueValues = [...new Set(values)].sort(); 
            config.categoricalMap = {}; 
            const palette = categoricalPalettes[config.activeCategoricalPalette]; 
            uniqueValues.forEach((value, index) => { config.categoricalMap[value] = palette[index % palette.length]; }); 
        } 
        
        const getDynamicStyle = function(feature) { 
            const currentConfig = this.options.config; 
            if (currentConfig.displayMode === 'classified') { 
                const value = feature.properties[currentConfig.activeVariable]; 
                const grades = currentConfig.numericStats[currentConfig.activeVariable].grades; 
                return { fillColor: getColor(value, grades, currentConfig.activePalette), weight: 1, opacity: 1, color: 'white', fillOpacity: 0.8 }; 
            } 
            if (currentConfig.displayMode === 'categorical') { 
                const value = feature.properties[currentConfig.activeCategoricalVariable]; 
                const color = currentConfig.categoricalMap[value] || '#CCCCCC'; 
                return { fillColor: color, weight: 1, opacity: 1, color: 'white', fillOpacity: 0.8 }; 
            } 
            return {};
        }.bind({options: {config: layer.options.config}});

        if (isPointLayer) {
             layer.eachLayer(function(l) {
                if (l instanceof L.CircleMarker) {
                    const style = getDynamicStyle(l.feature);
                    l.setStyle({ fillColor: style.fillColor, color: style.color, fillOpacity: style.fillOpacity, radius: 8 });
                }
            });
        } else {
            layer.setStyle(getDynamicStyle); 
        }
        
        if (layer === currentActiveLayer) { 
            legendControl.update(layer); 
        } 
    }

    function processData(geojson, name) { 
        const numericProperties = [], stringProperties = [], numericStats = {}; 
        let hasPoints = false;
        
        if (geojson.features && geojson.features.length > 0) { 
            const firstProps = geojson.features[0].properties; 
            for (const key in firstProps) { 
                if (typeof firstProps[key] === 'number') { 
                    numericProperties.push(key); 
                    numericStats[key] = {}; 
                } else if (typeof firstProps[key] === 'string') { 
                    stringProperties.push(key); 
                } 
            }
            hasPoints = geojson.features.some(f => f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint');
        } 

        const defaultMode = numericProperties.length > 0 ? 'classified' : (stringProperties.length > 0 ? 'categorical' : 'simple'); 
        const layerConfig = { 
            name, 
            numericProperties, 
            stringProperties, 
            numericStats, 
            activeVariable: numericProperties[0] || null, 
            activeCategoricalVariable: stringProperties[0] || null, 
            numClasses: 7, 
            activePalette: 'Blues', // Cambiado a Blues por defecto
            activeCategoricalPalette: 'Paired', 
            displayMode: defaultMode, 
            simpleRenderMode: 'both', 
            simpleFillColor: '#007BFF', // Color azul primario de la nueva paleta
            simpleOutlineColor: '#FFFFFF'
        }; 
        
        const geoJSONOptions = {
            config: layerConfig,
            style: function(feature) {
                return { color: "#007BFF", weight: 2, fillOpacity: 0.6 };
            },
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, {
                    radius: 8,
                    fillColor: layerConfig.simpleFillColor,
                    color: layerConfig.simpleOutlineColor,
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });
            }
        };

        const newLayer = L.geoJSON(geojson, geoJSONOptions);
        
        newLayer.options.pointLayer = hasPoints; 
        newLayer.addTo(map);

        newLayer.eachLayer(layer => { 
            let popupContent = '<table>'; 
            for (const key in layer.feature.properties) { 
                popupContent += `<tr><td style="padding-right: 10px;"><strong>${key}</strong></td><td>${layer.feature.properties[key]}</td></tr>`; 
            } 
            popupContent += '</table>'; 
            layer.bindPopup(popupContent, { maxHeight: 200, minWidth: 200 }); 
        }); 
        
        layerControl.addOverlay(newLayer, name); 
        orderedLayers.unshift(newLayer); 
        currentActiveLayer = newLayer; 
        infoControl.update(); 
        updateVisualization(currentActiveLayer); 
        applyLayerOrder(); 
    }
    infoControl.onAdd = function (map) { this._div = L.DomUtil.create('div', 'info'); L.DomEvent.disableClickPropagation(this._div); L.DomEvent.on(this._div, 'click', function(e) { if (e.target.tagName === 'H4') { this._div.classList.toggle('collapsed'); } }, this); this.update(); return this._div; };
    infoControl.update = function () { let htmlContent = '<h4>Configuración de Capas</h4>'; if (orderedLayers.length === 0) { htmlContent += '<p style="padding: 10px 0;">Cargue un archivo para empezar.</p>'; this._div.innerHTML = htmlContent; return; } htmlContent += `<label>Capas (arrastra para ordenar):</label><ul id="layer-list" class="layer-list">`; orderedLayers.forEach(layer => { const layerId = L.stamp(layer); const isActiveClass = (currentActiveLayer && layerId === L.stamp(currentActiveLayer)) ? 'active' : ''; htmlContent += `<li class="${isActiveClass}" data-layer-id="${layerId}">${layer.options.config.name}</li>`; }); htmlContent += `</ul>`; if (currentActiveLayer) { const config = currentActiveLayer.options.config; htmlContent += `<div class="config-options">`; htmlContent += `<label for="mode-selector">Modo de Visualización:</label><select id="mode-selector">`; htmlContent += `<option value="simple" ${config.displayMode === 'simple' ? 'selected' : ''}>Estilo Simple</option>`; if (config.numericProperties.length > 0) { htmlContent += `<option value="classified" ${config.displayMode === 'classified' ? 'selected' : ''}>Clasificado (Números)</option>`; } if (config.stringProperties.length > 0) { htmlContent += `<option value="categorical" ${config.displayMode === 'categorical' ? 'selected' : ''}>Por Categorías (Texto)</option>`; } htmlContent += `</select>`; if (config.displayMode === 'simple') { htmlContent += `<label for="render-mode-selector">Mostrar:</label><select id="render-mode-selector"><option value="both" ${config.simpleRenderMode === 'both' ? 'selected' : ''}>Relleno y Contorno</option><option value="fill" ${config.simpleRenderMode === 'fill' ? 'selected' : ''}>Solo Relleno</option><option value="outline" ${config.simpleRenderMode === 'outline' ? 'selected' : ''}>Solo Contorno</option></select>`; htmlContent += `<div class="color-picker-container"><label>Relleno:</label><input type="color" id="fill-color-picker" value="${config.simpleFillColor}"></div>`; htmlContent += `<div class="color-picker-container"><label>Contorno:</label><input type="color" id="outline-color-picker" value="${config.simpleOutlineColor}"></div>`; } if (config.displayMode === 'classified') { htmlContent += `<label for="variable-selector">Variable Numérica:</label><select id="variable-selector">`; config.numericProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeVariable ? 'selected' : ''}>${prop}</option>`; }); htmlContent += `</select>`; htmlContent += `<label for="classes-input">Clases:</label><input type="number" id="classes-input" value="${config.numClasses}" min="2" max="10">`; htmlContent += `<label for="palette-selector">Paleta:</label><select id="palette-selector">`; for (const key in sequentialPalettes) { htmlContent += `<option value="${key}" ${key === config.activePalette ? 'selected' : ''}>${key}</option>`; } htmlContent += `</select>`; } if (config.displayMode === 'categorical') { htmlContent += `<label for="categorical-variable-selector">Variable de Texto:</label><select id="categorical-variable-selector">`; config.stringProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeCategoricalVariable ? 'selected' : ''}>${prop}</option>`; }); htmlContent += `</select>`; htmlContent += `<label for="categorical-palette-selector">Paleta:</label><select id="categorical-palette-selector">`; for (const key in categoricalPalettes) { htmlContent += `<option value="${key}" ${key === config.activeCategoricalPalette ? 'selected' : ''}>${key}</option>`; } htmlContent += `</select>`; } htmlContent += `</div>`; } this._div.innerHTML = htmlContent; const layerListEl = this._div.querySelector('#layer-list'); if (layerListEl) { sortableInstance = new Sortable(layerListEl, { animation: 150, onEnd: (evt) => { const movedItem = orderedLayers.splice(evt.oldIndex, 1)[0]; orderedLayers.splice(evt.newIndex, 0, movedItem); applyLayerOrder(); infoControl.update(); } }); } this._div.querySelectorAll('#layer-list li').forEach(item => { item.addEventListener('click', () => { const layerId = parseInt(item.dataset.layerId, 10); currentActiveLayer = orderedLayers.find(l => L.stamp(l) === layerId); this.update(); legendControl.update(currentActiveLayer); }); }); if (currentActiveLayer) { const config = currentActiveLayer.options.config; const modeSelector = this._div.querySelector('#mode-selector'); if (modeSelector) { modeSelector.onchange = (e) => { config.displayMode = e.target.value; this.update(); updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'simple') { this._div.querySelector('#render-mode-selector').onchange = (e) => { config.simpleRenderMode = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#fill-color-picker').onchange = (e) => { config.simpleFillColor = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#outline-color-picker').onchange = (e) => { config.simpleOutlineColor = e.target.value; updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'classified') { this._div.querySelector('#variable-selector').onchange = (e) => { config.activeVariable = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#classes-input').onchange = (e) => { let val = parseInt(e.target.value, 10); if (val >= 2 && val <= 10) { config.numClasses = val; updateVisualization(currentActiveLayer); } else { e.target.value = config.numClasses; } }; this._div.querySelector('#palette-selector').onchange = (e) => { config.activePalette = e.target.value; updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'categorical') { this._div.querySelector('#categorical-variable-selector').onchange = (e) => { config.activeCategoricalVariable = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#categorical-palette-selector').onchange = (e) => { config.activeCategoricalPalette = e.target.value; updateVisualization(currentActiveLayer); }; } } };
    infoControl.addTo(map);
    legendControl.onAdd = function (map) { this._div = L.DomUtil.create('div', 'info legend'); return this._div; };
    legendControl.update = function (layer) { let content = ""; if (layer && layer.options.config.displayMode === 'classified' && layer.options.config.numericStats[layer.options.config.activeVariable].grades?.length > 1) { const config = layer.options.config; const grades = config.numericStats[config.activeVariable].grades; const palette = sequentialPalettes[config.activePalette]; let labels = ['<h4>' + config.activeVariable + '</h4>']; for (let i = 0; i < grades.length - 1; i++) { if (palette[i]) { labels.push(`<i style="background:${palette[i]}"></i> ${grades[i].toLocaleString(undefined, {maximumFractionDigits: 2})} &ndash; ${grades[i+1].toLocaleString(undefined, {maximumFractionDigits: 2})}`); } } content = labels.join('<br>'); } else if (layer && layer.options.config.displayMode === 'categorical' && layer.options.config.categoricalMap) { const config = layer.options.config; let labels = ['<h4>' + config.activeCategoricalVariable + '</h4>']; for (const value in config.categoricalMap) { labels.push(`<i style="background:${config.categoricalMap[value]}"></i> ${value}`); } content = labels.join('<br>'); } this._div.innerHTML = content; };
    legendControl.addTo(map);
    function applyLayerOrder() { orderedLayers.forEach(layer => layer.bringToFront()); }
    map.on('overlayadd', e => { const index = orderedLayers.findIndex(l => L.stamp(l) === L.stamp(e.layer)); if (index === -1) { orderedLayers.unshift(e.layer); } if (!currentActiveLayer) { currentActiveLayer = e.layer; } applyLayerOrder(); infoControl.update(); legendControl.update(currentActiveLayer); });
    map.on('overlayremove', e => { const layerIdToRemove = L.stamp(e.layer); orderedLayers = orderedLayers.filter(layer => L.stamp(layer) !== layerIdToRemove); if (e.layer === currentActiveLayer) { currentActiveLayer = orderedLayers.length > 0 ? orderedLayers[0] : null; } infoControl.update(); legendControl.update(currentActiveLayer); });
    function handleUploadedFile(file) {
        if (!file) return;
        const extension = file.name.split('.').pop().toLowerCase();
        const reader = new FileReader();

        const loadingMessage = L.DomUtil.create('div', 'loading-indicator', map.getContainer());
        loadingMessage.innerText = `Cargando ${file.name}...`;

        reader.onload = function(event) {
            try {
                if (extension === 'zip') {
                    shp(event.target.result).then(function(geojson){
                        if (Array.isArray(geojson)) {
                            geojson.forEach(featureCollection => {
                                processData(featureCollection, featureCollection.name || file.name);
                            });
                        } else {
                            processData(geojson, file.name);
                        }
                        map.getContainer().removeChild(loadingMessage);
                    }).catch(err => {
                        alert("Error procesando Shapefile: " + err.message);
                        map.getContainer().removeChild(loadingMessage);
                    });
                } else if (extension === 'geojson' || extension === 'json') {
                    processData(JSON.parse(event.target.result), file.name);
                    map.getContainer().removeChild(loadingMessage);
                }
            } catch (err) {
                alert("Error procesando el archivo: " + err.message);
                map.getContainer().removeChild(loadingMessage);
            }
        };
        reader.onerror = function() {
            alert("Error al leer el archivo.");
            map.getContainer().removeChild(loadingMessage);
        };

        if (extension === 'zip') {
            reader.readAsArrayBuffer(file);
        } else {
            reader.readAsText(file);
        }
    }
    
    L.Control.Custom = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-control');
            container.innerText = 'Cargar Archivo(s)';
            
            const fileInput = L.DomUtil.create('input');
            fileInput.type = 'file';
            fileInput.accept = ".geojson,.json,.zip";
            fileInput.multiple = true;
            fileInput.style.display = 'none';
            
            container.appendChild(fileInput);

            fileInput.onchange = (e) => { 
                if (!e.target.files) return; 
                for (const file of e.target.files) { 
                    handleUploadedFile(file); 
                } 
                e.target.value = '';
            };
            
            L.DomEvent.disableClickPropagation(container);
            L.DomEvent.on(container, 'click', function() {
                fileInput.click();
            });

            return container;
        }
    });
    new L.Control.Custom({ position: 'topleft' }).addTo(map);

    function exportMap() {
        const controlsToHide = document.querySelectorAll(
            '.leaflet-control-container > .leaflet-top, ' +
            '.leaflet-control-container > .leaflet-bottom-left, ' +
            '.info.leaflet-control'
        );
        controlsToHide.forEach(el => el.classList.add('hide-for-export'));

        leafletImage(map, function(err, canvas) {
            controlsToHide.forEach(el => el.classList.remove('hide-for-export'));
            if (err) {
                console.error("Error al exportar el mapa con leaflet-image:", err);
                alert("Hubo un error al exportar el mapa. Por favor, inténtelo de nuevo.");
            } else {
                const link = document.createElement('a');
                link.download = 'mapa_exportado.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
        });
    }

    L.Control.Export = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-control');
            container.innerText = 'Exportar Imagen';
            L.DomEvent.on(container, 'click', function(e) { L.DomEvent.stopPropagation(e); exportMap(); });
            return container;
        }
    });
    new L.Control.Export({ position: 'topleft' }).addTo(map);

    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
        edit: {
            featureGroup: drawnItems,
            remove: true
        },
        draw: {
            polygon: {
                allowIntersection: false,
                showArea: true
            },
            polyline: true,
            rectangle: true,
            circle: false,
            marker: false
        }
    });
    map.addControl(drawControl);

    map.on(L.Draw.Event.CREATED, function (e) {
        const layer = e.layer;
        const type = e.layerType;
        let content = '';

        if (type === 'polyline') {
            let distance = 0;
            const latlngs = layer.getLatLngs();
            for (let i = 0; i < latlngs.length - 1; i++) {
                distance += latlngs[i].distanceTo(latlngs[i+1]);
            }
            content = `Distancia: ${ (distance / 1000).toFixed(2) } km`;
        } else if (type === 'polygon' || type === 'rectangle') {
            const area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
            content = `Área: ${ (area / 10000).toFixed(2) } hectáreas`;
        }
        
        if (content) {
            layer.bindPopup(content).openPopup();
        }
        
        drawnItems.addLayer(layer);
        
        drawnItemsHistory.push(layer); 
    });

    function undoLastDrawAction() {
        if (drawnItemsHistory.length > 0) {
            const lastDrawnLayer = drawnItemsHistory.pop();
            if (drawnItems.hasLayer(lastDrawnLayer)) {
                drawnItems.removeLayer(lastDrawnLayer);
            }
        }
    }

    document.addEventListener('keydown', function(event) {
        const isCtrlOrCmdZ = (event.ctrlKey || event.metaKey) && event.key === 'z';
        const isInputTarget = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';

        if (isCtrlOrCmdZ && !isInputTarget) {
            event.preventDefault();
            undoLastDrawAction();
        }
    });

</script>
</body>
</html>
