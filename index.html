<!DOCTYPE html>
<html>
<head>
    <title>Geoportal beta</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil@latest/src/leaflet.geometryutil.js"></script>
    <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>
    <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
    <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-blue: #007BFF;
            --light-blue: #E6F2FF;
            --dark-blue: #0056b3;
            --text-color: #333;
            --border-color: #DEE2E6;
            --background-color: #F8F9FA;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 4px 8px rgba(0,0,0,0.1);
            /* --- NUEVO --- Color para resaltado */
            --highlight-color: #FFC107; 
        }

        html, body, #map {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            font-family: 'Roboto', sans-serif;
        }

        .leaflet-bar, .info {
            background-color: var(--panel-bg);
            border-radius: 8px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }
        
        .leaflet-bar a, .leaflet-bar a:hover {
            border-radius: 6px;
            color: var(--primary-blue);
        }

        .custom-control {
            /* --- MODIFICADO --- Ajustes para íconos */
            padding: 8px;
            line-height: 1;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            color: var(--primary-blue);
        }
        /* --- NUEVO --- Estilo para SVG dentro de botones */
        .custom-control svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            vertical-align: middle;
        }

        .custom-control:hover {
            background-color: var(--light-blue);
            color: var(--dark-blue);
            border-color: var(--primary-blue);
        }
        .leaflet-top.leaflet-left .custom-control + .custom-control {
            margin-top: 10px;
        }

        .info {
            padding: 10px 15px;
            font-size: 14px;
            line-height: 1.5;
            max-height: 80vh;
            overflow-y: auto;
            /* --- NUEVO --- Evita que el texto del panel sea seleccionado al arrastrar */
            user-select: none;
        }
        .info h4 {
            margin: -10px -15px 15px -15px;
            padding: 12px 15px;
            color: var(--dark-blue);
            background-color: var(--light-blue);
            border-bottom: 1px solid var(--border-color);
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            cursor: pointer;
            font-weight: 700;
        }
        .info h4::after { content: ' ▼'; font-size: 12px; float: right; transition: transform 0.2s; }
        .info.collapsed { max-height: 50px; overflow: hidden; }
        .info.collapsed h4::after { transform: rotate(-90deg); }

        .legend { text-align: left; line-height: 22px; color: var(--text-color); max-height: 300px; overflow-y: auto; }
        .legend i { 
            width: 18px; 
            height: 18px; 
            float: left; 
            margin-right: 8px; 
            border-radius: 4px; 
            border: 1px solid rgba(0,0,0,0.1); 
            /* --- NUEVO --- Para alinear mejor los íconos de círculos */
            display: inline-block;
            vertical-align: middle;
            margin-top: 2px;
        }
        .legend h4 { background: none; margin: 0 0 10px; padding: 0; color: var(--text-color); font-size: 16px; border: none; }
        
        
        .info label { display: block; margin-top: 12px; margin-bottom: 4px; font-weight: 500; color: #555; font-size: 13px; }
        .info select, .info input[type="number"], .info input[type="color"], .info input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: #fff;
            box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        /* --- NUEVO --- Estilo para el slider de opacidad */
        .info input[type="range"] {
            padding: 0;
            height: 18px;
            margin-top: 8px;
            cursor: pointer;
        }
        
        .info select:focus, .info input[type="number"]:focus {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
            outline: none;
        }
        .info input[type="color"] { height: 38px; padding: 2px; cursor: pointer; }
        
        .config-options { border-top: 1px solid var(--border-color); margin-top: 15px; padding-top: 10px; }
        .color-picker-container { display: flex; align-items: center; justify-content: space-between; margin-top: 8px; }

        /* --- NUEVO --- Contenedor para botones de capa */
        .layer-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        .layer-controls button {
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .layer-controls button:hover {
            background: var(--dark-blue);
        }


        .layer-list { list-style: none; padding: 0; margin: 5px 0 15px 0; }
        .layer-list li {
            background-color: #fff;
            border: 1px solid var(--border-color);
            padding: 10px;
            margin-bottom: -1px;
            font-size: 14px;
            cursor: grab; /* --- MODIFICADO --- Mejor cursor para arrastrar */
            user-select: none;
            transition: background-color 0.2s;
        }
        .layer-list li:first-child { border-top-left-radius: 6px; border-top-right-radius: 6px; }
        .layer-list li:last-child { border-bottom-left-radius: 6px; border-bottom-right-radius: 6px; }
        .layer-list li:hover { background-color: var(--light-blue); }
        .layer-list li.active {
            font-weight: bold;
            color: var(--dark-blue);
            background-color: var(--light-blue);
            border-left: 4px solid var(--primary-blue);
            padding-left: 7px;
        }
        .layer-list li.sortable-ghost { background: #c8ebfb; opacity: 0.7; }

        #map-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(44, 62, 80, 0.85); 
            color: #FFFFFF;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: 500;
            box-shadow: var(--shadow);
            pointer-events: none; 
        }
        
        .loading-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 1000;
            font-size: 14px;
            color: var(--text-color);
            box-shadow: var(--shadow);
        }


        .custom-attribution {
            position: absolute;
            bottom: 0;
            right: 0;
            padding: 4px 10px;
            background: var(--panel-bg);
            color: #555;
            font-size: 12px;
            z-index: 1000;
            border-top-left-radius: 8px;
        }
        .custom-attribution a { color: var(--primary-blue); text-decoration: none; }
        .custom-attribution a:hover { text-decoration: underline; }

        .hide-for-export { display: none !important; }

        /* --- NUEVO --- Estilos para Popups */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
            box-shadow: var(--shadow);
        }
        .leaflet-popup-content {
            font-family: 'Roboto', sans-serif;
            margin: 15px 20px;
        }
        .leaflet-popup-content table {
            width: 100%;
            border-collapse: collapse;
        }
        .leaflet-popup-content th,
        .leaflet-popup-content td {
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
        }
        .leaflet-popup-content tr:last-child td {
            border-bottom: none;
        }
        .leaflet-popup-content td:first-child {
            font-weight: 500;
            color: var(--text-color);
            padding-right: 15px;
        }

    </style>
</head>
<body>

<div id="map-title">Geoportal beta</div>

<div id="map"></div>

<div class="custom-attribution">
    Elaborado con <a href="https://leafletjs.com/" target="_blank">Leaflet</a> | Por Gabriela Reséndiz Colorado | Fines académicos
</div>

<script>
    // =========================================================================

    const map = L.map('map', { attributionControl: false, preferCanvas: true }).setView([24.5, -99.5], 5);
    
    const infoControl = L.control();
    const legendControl = L.control({position: 'bottomright'});
    let currentActiveLayer = null;
    let orderedLayers = [];
    let sortableInstance = null;
    
    let drawnItemsHistory = []; 
    let highlightLayer = null; // --- NUEVO --- Para guardar la capa resaltada

    const oceanBasemap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' });
    const streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'OpenStreetMap' });
    const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' });
    const baseMaps = { "Océano": oceanBasemap, "Calles": streets, "Satélite": satellite };
    const layerControl = L.control.layers(baseMaps, {}, { collapsed: true }).addTo(map);
    oceanBasemap.addTo(map);
    
    L.control.attribution({ position: 'bottomleft', prefix: false }).addTo(map);
    
    const sequentialPalettes = { 'YlOrRd': ['#FFFFE5','#FFF7BC','#FEE391','#FEC44F','#FE9929','#EC7014','#CC4C02','#993404','#662506','#4C1B03'], 'Blues': ['#F7FBFF','#DEEBF7','#C6DBEF','#9ECAE1','#6BAED6','#4292C6','#2171B5','#08519C','#08306B'], 'Greens': ['#F7F7F7','#E5F5E0','#C7E9C0','#A1D99B','#74C476','#41AB5D','#238B45','#006D2C','#00441B','#002B12'], 'Reds': ['#FFF5F0','#FEE0D2','#FCBBA1','#FC9272','#FB6A4A','#EF3B2C','#CB181D','#A50F15','#67000D','#4A0008'] };
    const categoricalPalettes = { 'Paired': ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff9D9','#b15928'], 'Accent': ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666'], 'Set1': ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'] };

    // --- FUNCIONES Y CONTROLES ---

    // --- NUEVO --- Función de ayuda para escalar radios
    function getRadius(value, grades, minRadius, maxRadius) {
        if (value === undefined || value === null) return minRadius;
        const paletteLength = grades.length - 1; // e.g., 5 grades -> 4 classes
        for (let i = paletteLength - 1; i >= 0; i--) {
            if (value > grades[i]) {
                // Escala lineal simple basada en el índice de la clase
                return minRadius + (i / (paletteLength - 1)) * (maxRadius - minRadius);
            }
        }
        if (value === grades[0]) return minRadius;
        return minRadius; // Fallback
    }

    function getColor(value, grades, paletteName) { if (value === undefined || value === null) return '#CCCCCC'; const palette = sequentialPalettes[paletteName]; for (let i = grades.length - 2; i >= 0; i--) { if (value > grades[i]) { return palette[i % palette.length]; } } if (value === grades[0]) return palette[0]; return '#CCCCCC'; }
    
    // Esta función está bien, la lógica de mi "Intento 3" era correcta.
    // El problema NO está aquí, está en las funciones de highlight.
    function updateVisualization(layer) { 
        if (!layer) return; 
        const config = layer.options.config; 
        
        const isPointLayer = layer.options.pointLayer;
        
        if (config.displayMode === 'simple') { 
            let simpleStyle = { 
                weight: 2, 
                color: config.simpleOutlineColor, 
                fillColor: config.simpleFillColor,
                fillOpacity: config.globalOpacity
            }; 
            switch(config.simpleRenderMode) { 
                case 'both': simpleStyle.stroke = true; simpleStyle.fill = true; break;
                case 'fill': simpleStyle.stroke = false; simpleStyle.fill = true; break;
                case 'outline': simpleStyle.stroke = true; simpleStyle.fill = false; break; 
            } 
            
            if (isPointLayer) {
                layer.setStyle({
                    fillColor: config.simpleFillColor, 
                    color: config.simpleOutlineColor, 
                    fillOpacity: config.globalOpacity,
                    radius: config.minRadius,
                    weight: 1 // Peso de borde para puntos
                });
            } else {
                layer.setStyle(simpleStyle); 
            }
            if (layer === currentActiveLayer) legendControl.update(null); 
            return; 
        } 
        
        if (config.displayMode === 'classified' || config.displayMode === 'graduated') { 
            const values = layer.toGeoJSON().features.map(f => f.properties[config.activeVariable]).filter(v => v !== null && typeof v === 'number' && isFinite(v)); 
            const uniqueValues = [...new Set(values)]; 
            if (uniqueValues.length < 2) { 
                config.numericStats[config.activeVariable].grades = []; 
            } else { 
                const classCount = Math.min(uniqueValues.length, config.numClasses, sequentialPalettes[config.activePalette].length); 
                config.numericStats[config.activeVariable].grades = ss.jenks(values, classCount); 
            } 
        } 
        
        if (config.displayMode === 'categorical') { 
            const values = layer.toGeoJSON().features.map(f => f.properties[config.activeCategoricalVariable]); 
            const uniqueValues = [...new Set(values)].sort(); 
            config.categoricalMap = {}; 
            const palette = categoricalPalettes[config.activeCategoricalPalette]; 
            uniqueValues.forEach((value, index) => { config.categoricalMap[value] = palette[index % palette.length]; }); 
        } 
        
        const getDynamicStyle = function(feature) { 
            const currentConfig = this.options.config; 
            const value = feature.properties[currentConfig.activeVariable];
            const grades = currentConfig.numericStats[currentConfig.activeVariable]?.grades || [];

            if (currentConfig.displayMode === 'classified') { 
                return { 
                    fillColor: getColor(value, grades, currentConfig.activePalette), 
                    weight: 1, 
                    opacity: 1, 
                    color: 'white', 
                    fillOpacity: currentConfig.globalOpacity,
                    radius: currentConfig.minRadius
                }; 
            } 
            if (currentConfig.displayMode === 'categorical') { 
                const catValue = feature.properties[currentConfig.activeCategoricalVariable]; 
                const color = currentConfig.categoricalMap[catValue] || '#CCCCCC'; 
                return { 
                    fillColor: color, 
                    weight: 1, 
                    opacity: 1, 
                    color: 'white', 
                    fillOpacity: currentConfig.globalOpacity,
                    radius: currentConfig.minRadius
                }; 
            } 
            if (currentConfig.displayMode === 'graduated') {
                return {
                    fillColor: getColor(value, grades, currentConfig.activePalette),
                    weight: 1,
                    opacity: 1,
                    color: 'white',
                    fillOpacity: currentConfig.globalOpacity,
                    radius: getRadius(value, grades, currentConfig.minRadius, currentConfig.maxRadius)
                };
            }
            return {};
        }.bind({options: {config: layer.options.config}});

        layer.setStyle(getDynamicStyle); 
        
        if (layer === currentActiveLayer) { 
            legendControl.update(layer); 
        } 
    }

    function processData(geojson, name) { 
        const numericProperties = [], stringProperties = [], numericStats = {}; 
        let hasPoints = false;
        
        if (geojson.features && geojson.features.length > 0) { 
            const firstProps = geojson.features[0].properties; 
            for (const key in firstProps) { 
                if (typeof firstProps[key] === 'number') { 
                    numericProperties.push(key); 
                    numericStats[key] = {}; 
                } else if (typeof firstProps[key] === 'string') { 
                    stringProperties.push(key); 
                } 
            }
            hasPoints = geojson.features.some(f => f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint');
        } 

        const defaultMode = numericProperties.length > 0 ? 'classified' : (stringProperties.length > 0 ? 'categorical' : 'simple'); 
        
        const layerConfig = { 
            name, 
            numericProperties, 
            stringProperties, 
            numericStats, 
            activeVariable: numericProperties[0] || null, 
            activeCategoricalVariable: stringProperties[0] || null, 
            numClasses: 7, 
            activePalette: 'Blues',
            activeCategoricalPalette: 'Paired', 
            displayMode: defaultMode, 
            simpleRenderMode: 'both', 
            simpleFillColor: '#007BFF',
            simpleOutlineColor: '#FFFFFF',
            globalOpacity: 0.8,
            minRadius: 6,
            maxRadius: 20
        }; 
        
        

        const geoJSONOptions = {
            config: layerConfig,
            style: function(feature) {
                return { color: "#007BFF", weight: 2, fillOpacity: 0.6 };
            },
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, {
                    radius: layerConfig.minRadius,
                    fillColor: layerConfig.simpleFillColor,
                    color: layerConfig.simpleOutlineColor,
                    weight: 1,
                    opacity: 1,
                    fillOpacity: layerConfig.globalOpacity
                });
            }
        };

        const newLayer = L.geoJSON(geojson, geoJSONOptions);
        
        newLayer.options.pointLayer = hasPoints; 

        // =========================================================================
        // ===== INICIO DE LA SECCIÓN CORREGIDA (CANVAS) ===========================
        // =========================================================================

        // Esta es la forma correcta de resaltar en modo CANVAS.
        // No modificamos la capa original, sino que creamos una capa temporal encima.

        function highlightFeature(e) {
            const layer = e.target;

            // Si ya hay una capa resaltada, la quitamos primero
            if (highlightLayer) {
                map.removeLayer(highlightLayer);
                highlightLayer = null;
            }

            // Estilo para el resaltado
            const highlightStyle = {
                weight: 3,
                color: 'var(--highlight-color)',
                dashArray: '',
                fillColor: 'var(--highlight-color)',
                fillOpacity: 0.4 // Le damos algo de opacidad
            };

            if (layer instanceof L.CircleMarker) {
                // Para puntos, creamos un nuevo círculo temporal
                highlightLayer = L.circleMarker(layer.getLatLng(), {
                    ...highlightStyle,
                    radius: layer.options.radius * 1.2
                }).addTo(map);
            } else {
                // Para polígonos/líneas, creamos un GeoJSON temporal
                highlightLayer = L.geoJSON(layer.toGeoJSON(), {
                    style: highlightStyle
                }).addTo(map);
            }
        }

        function resetHighlight(e) {
            // En mouseout, simplemente eliminamos la capa temporal
            if (highlightLayer) {
                map.removeLayer(highlightLayer);
                highlightLayer = null;
            }
            // NO usamos resetStyle() en la capa original (newLayer)
        }
        
        // =========================================================================
        // ===== FIN DE LA SECCIÓN CORREGIDA (CANVAS) ==============================
        // =========================================================================
        
        newLayer.addTo(map);

        // Asignamos los listeners y popups
        newLayer.eachLayer(layer => { 
            // 1. Asignar los listeners
            layer.on({
                mouseover: highlightFeature,
                mouseout: resetHighlight
            });

            // 2. Asignar el popup
            let popupContent = '<table>'; 
            for (const key in layer.feature.properties) { 
                popupContent += `<tr><td><strong>${key}</strong></td><td>${layer.feature.properties[key]}</td></tr>`; 
            } 
            popupContent += '</table>'; 
            layer.bindPopup(popupContent, { maxHeight: 200, minWidth: 200 }); 
        }); 
        
        layerControl.addOverlay(newLayer, name); 
        orderedLayers.unshift(newLayer); 
        currentActiveLayer = newLayer; 
        infoControl.update(); 
        updateVisualization(currentActiveLayer); 
        applyLayerOrder(); 
    }

    infoControl.onAdd = function (map) { this._div = L.DomUtil.create('div', 'info'); L.DomEvent.disableClickPropagation(this._div); L.DomEvent.on(this._div, 'click', function(e) { if (e.target.tagName === 'H4') { this._div.classList.toggle('collapsed'); } }, this); this.update(); return this._div; };
    
    infoControl.update = function () { 
        let htmlContent = '<h4>Configuración de Capas</h4>'; 
        if (orderedLayers.length === 0) { 
            htmlContent += '<p style="padding: 10px 0;">Cargue un archivo para empezar.</p>'; 
            this._div.innerHTML = htmlContent; return; 
        } 
        htmlContent += `<label>Capas (arrastra para ordenar):</label><ul id="layer-list" class="layer-list">`; 
        orderedLayers.forEach(layer => { const layerId = L.stamp(layer); const isActiveClass = (currentActiveLayer && layerId === L.stamp(currentActiveLayer)) ? 'active' : ''; htmlContent += `<li class="${isActiveClass}" data-layer-id="${layerId}">${layer.options.config.name}</li>`; }); 
        htmlContent += `</ul>`; 
        
        if (currentActiveLayer) { 
            const config = currentActiveLayer.options.config; 
            
            htmlContent += `<div class="layer-controls">
                                <button id="zoom-to-layer-btn">Zoom a la Capa</button>
                           </div>`;

            htmlContent += `<div class="config-options">`; 

            htmlContent += `<label for="opacity-slider">Opacidad: <span id="opacity-value">${Math.round(config.globalOpacity * 100)}%</span></label>`;
            htmlContent += `<input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="${config.globalOpacity}">`;

            htmlContent += `<label for="mode-selector">Modo de Visualización:</label><select id="mode-selector">`; 
            htmlContent += `<option value="simple" ${config.displayMode === 'simple' ? 'selected' : ''}>Estilo Simple</option>`; 
            if (config.numericProperties.length > 0) { 
                htmlContent += `<option value="classified" ${config.displayMode === 'classified' ? 'selected' : ''}>Clasificado (Polígonos)</option>`; 
            } 
            if (config.numericProperties.length > 0 && config.pointLayer) {
                htmlContent += `<option value="graduated" ${config.displayMode === 'graduated' ? 'selected' : ''}>Graduado (Puntos)</option>`;
            }
            if (config.stringProperties.length > 0) { 
                htmlContent += `<option value="categorical" ${config.displayMode === 'categorical' ? 'selected' : ''}>Por Categorías (Texto)</option>`; 
            } 
            htmlContent += `</select>`; 
            
            if (config.displayMode === 'simple') { 
                htmlContent += `<label for="render-mode-selector">Mostrar:</label><select id="render-mode-selector"><option value="both" ${config.simpleRenderMode === 'both' ? 'selected' : ''}>Relleno y Contorno</option><option value="fill" ${config.simpleRenderMode === 'fill' ? 'selected' : ''}>Solo Relleno</option><option value="outline" ${config.simpleRenderMode === 'outline' ? 'selected' : ''}>Solo Contorno</option></select>`; 
                htmlContent += `<div class="color-picker-container"><label>Relleno:</label><input type="color" id="fill-color-picker" value="${config.simpleFillColor}"></div>`; 
                htmlContent += `<div class="color-picker-container"><label>Contorno:</label><input type="color" id="outline-color-picker" value="${config.simpleOutlineColor}"></div>`; 
                if (config.pointLayer) {
                     htmlContent += `<label for="radius-input">Radio:</label><input type="number" id="radius-input" value="${config.minRadius}" min="1" max="30">`;
                }
            } 
            
            if (config.displayMode === 'classified') { 
                htmlContent += `<label for="variable-selector">Variable Numérica:</label><select id="variable-selector">`; 
                config.numericProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeVariable ? 'selected' : ''}>${prop}</option>`; }); 
                htmlContent += `</select>`; 
                htmlContent += `<label for="classes-input">Clases:</label><input type="number" id="classes-input" value="${config.numClasses}" min="2" max="10">`; 
                htmlContent += `<label for="palette-selector">Paleta:</label><select id="palette-selector">`; 
                for (const key in sequentialPalettes) { htmlContent += `<option value="${key}" ${key === config.activePalette ? 'selected' : ''}>${key}</option>`; } 
                htmlContent += `</select>`; 
            } 

            if (config.displayMode === 'graduated') {
                htmlContent += `<label for="variable-selector">Variable Numérica:</label><select id="variable-selector">`; 
                config.numericProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeVariable ? 'selected' : ''}>${prop}</option>`; }); 
                htmlContent += `</select>`; 
                htmlContent += `<label for="classes-input">Clases:</label><input type="number" id="classes-input" value="${config.numClasses}" min="2" max="10">`;
                htmlContent += `<label for="palette-selector">Paleta de Color:</label><select id="palette-selector">`; 
                for (const key in sequentialPalettes) { htmlContent += `<option value="${key}" ${key === config.activePalette ? 'selected' : ''}>${key}</option>`; } 
                htmlContent += `</select>`; 
                htmlContent += `<label for="min-radius-input">Radio Mínimo:</label><input type="number" id="min-radius-input" value="${config.minRadius}" min="1" max="50">`;
                htmlContent += `<label for="max-radius-input">Radio Máximo:</label><input type="number" id="max-radius-input" value="${config.maxRadius}" min="1" max="50">`;
            }
            
            if (config.displayMode === 'categorical') { 
                htmlContent += `<label for="categorical-variable-selector">Variable de Texto:</label><select id="categorical-variable-selector">`; 
                config.stringProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeCategoricalVariable ? 'selected' : ''}>${prop}</option>`; }); 
                htmlContent += `</select>`; 
                htmlContent += `<label for="categorical-palette-selector">Paleta:</label><select id="categorical-palette-selector">`; 
                for (const key in categoricalPalettes) { htmlContent += `<option value="${key}" ${key === config.activeCategoricalPalette ? 'selected' : ''}>${key}</option>`; } 
                htmlContent += `</select>`; 
            } 
            htmlContent += `</div>`; 
        } 
        
        this._div.innerHTML = htmlContent; 
        
        const layerListEl = this._div.querySelector('#layer-list'); 
        if (layerListEl) { 
            sortableInstance = new Sortable(layerListEl, { animation: 150, onEnd: (evt) => { const movedItem = orderedLayers.splice(evt.oldIndex, 1)[0]; orderedLayers.splice(evt.newIndex, 0, movedItem); applyLayerOrder(); infoControl.update(); } }); 
        } 
        
        this._div.querySelectorAll('#layer-list li').forEach(item => { 
            item.addEventListener('click', () => { 
                const layerId = parseInt(item.dataset.layerId, 10); 
                currentActiveLayer = orderedLayers.find(l => L.stamp(l) === layerId); 
                this.update(); 
                legendControl.update(currentActiveLayer); 
            }); 
        }); 

        if (currentActiveLayer) {
            const config = currentActiveLayer.options.config;
            
            const zoomBtn = this._div.querySelector('#zoom-to-layer-btn');
            if (zoomBtn) {
                zoomBtn.onclick = () => { 
                    if (currentActiveLayer.getBounds && currentActiveLayer.getBounds().isValid()) {
                        map.fitBounds(currentActiveLayer.getBounds()); 
                    }
                };
            }

            const opacitySlider = this._div.querySelector('#opacity-slider');
            const opacityValue = this._div.querySelector('#opacity-value');
            if (opacitySlider) {
                opacitySlider.oninput = (e) => {
                    config.globalOpacity = parseFloat(e.target.value);
                    if (opacityValue) {
                        opacityValue.innerText = `${Math.round(config.globalOpacity * 100)}%`;
                    }
                    updateVisualization(currentActiveLayer);
                };
            }
            
            const modeSelector = this._div.querySelector('#mode-selector'); 
            if (modeSelector) { 
                modeSelector.onchange = (e) => { config.displayMode = e.target.value; this.update(); updateVisualization(currentActiveLayer); }; 
            } 

            if (config.displayMode === 'simple') { 
                const renderMode = this._div.querySelector('#render-mode-selector');
                if (renderMode) renderMode.onchange = (e) => { config.simpleRenderMode = e.target.value; updateVisualization(currentActiveLayer); }; 
                
                const fillColor = this._div.querySelector('#fill-color-picker');
                if (fillColor) fillColor.onchange = (e) => { config.simpleFillColor = e.target.value; updateVisualization(currentActiveLayer); }; 
                
                const outlineColor = this._div.querySelector('#outline-color-picker');
                if (outlineColor) outlineColor.onchange = (e) => { config.simpleOutlineColor = e.target.value; updateVisualization(currentActiveLayer); }; 
                
                const radiusInput = this._div.querySelector('#radius-input');
                if (radiusInput) radiusInput.onchange = (e) => { config.minRadius = parseInt(e.target.value, 10); updateVisualization(currentActiveLayer); };
            } 

            if (config.displayMode === 'classified') { 
                const varSelector = this._div.querySelector('#variable-selector');
                if (varSelector) varSelector.onchange = (e) => { config.activeVariable = e.target.value; updateVisualization(currentActiveLayer); }; 
                
                const classesInput = this._div.querySelector('#classes-input');
                if (classesInput) classesInput.onchange = (e) => { let val = parseInt(e.target.value, 10); if (val >= 2 && val <= 10) { config.numClasses = val; updateVisualization(currentActiveLayer); } else { e.target.value = config.numClasses; } }; 
                
                const paletteSelector = this._div.querySelector('#palette-selector');
                if (paletteSelector) paletteSelector.onchange = (e) => { config.activePalette = e.target.value; updateVisualization(currentActiveLayer); }; 
            } 

            if (config.displayMode === 'graduated') {
                const varSelector = this._div.querySelector('#variable-selector');
                if (varSelector) varSelector.onchange = (e) => { config.activeVariable = e.target.value; updateVisualization(currentActiveLayer); }; 
                
                const classesInput = this._div.querySelector('#classes-input');
                if (classesInput) classesInput.onchange = (e) => { let val = parseInt(e.target.value, 10); if (val >= 2 && val <= 10) { config.numClasses = val; updateVisualization(currentActiveLayer); } else { e.target.value = config.numClasses; } }; 
                
                const paletteSelector = this._div.querySelector('#palette-selector');
                if (paletteSelector) paletteSelector.onchange = (e) => { config.activePalette = e.target.value; updateVisualization(currentActiveLayer); }; 
                
                const minRadiusInput = this._div.querySelector('#min-radius-input');
                if (minRadiusInput) minRadiusInput.onchange = (e) => { config.minRadius = parseInt(e.target.value, 10); updateVisualization(currentActiveLayer); };

                const maxRadiusInput = this._div.querySelector('#max-radius-input');
                if (maxRadiusInput) maxRadiusInput.onchange = (e) => { config.maxRadius = parseInt(e.target.value, 10); updateVisualization(currentActiveLayer); };
            }
            
            if (config.displayMode === 'categorical') { 
                const catVarSelector = this._div.querySelector('#categorical-variable-selector');
                if (catVarSelector) catVarSelector.onchange = (e) => { config.activeCategoricalVariable = e.target.value; updateVisualization(currentActiveLayer); }; 
                
                const catPaletteSelector = this._div.querySelector('#categorical-palette-selector');
                if (catPaletteSelector) catPaletteSelector.onchange = (e) => { config.activeCategoricalPalette = e.target.value; updateVisualization(currentActiveLayer); }; 
            } 
        } 
    };
    infoControl.addTo(map);

    legendControl.onAdd = function (map) { this._div = L.DomUtil.create('div', 'info legend'); return this._div; };
    legendControl.update = function (layer) { 
        let content = ""; 
        if (!layer) {
             this._div.innerHTML = content;
             return;
        }

        const config = layer.options.config;
        const grades = config.numericStats[config.activeVariable]?.grades || [];

        if ((config.displayMode === 'classified' || config.displayMode === 'graduated') && grades.length > 1) { 
            const palette = sequentialPalettes[config.activePalette]; 
            let labels = ['<h4>' + config.activeVariable + '</h4>'];
            const isPoint = config.pointLayer;
            const isGraduated = isPoint && config.displayMode === 'graduated';

            for (let i = 0; i < grades.length - 1; i++) { 
                if (palette[i]) { 
                    let style = `background:${palette[i]}`;
                    if (isGraduated) {
                        const radius = config.minRadius + (i / (grades.length - 2)) * (config.maxRadius - config.minRadius);
                        style += `; width: ${radius*2}px; height: ${radius*2}px; border-radius: 50%;`;
                    } else if (isPoint) {
                        style += `; border-radius: 50%;`;
                    }
                    labels.push(`<i style="${style}"></i> ${grades[i].toLocaleString(undefined, {maximumFractionDigits: 2})} &ndash; ${grades[i+1].toLocaleString(undefined, {maximumFractionDigits: 2})}`); 
                } 
            } 
            content = labels.join('<br>'); 
        } else if (layer && config.displayMode === 'categorical' && config.categoricalMap) { 
            let labels = ['<h4>' + config.activeCategoricalVariable + '</h4>']; 
            for (const value in config.categoricalMap) { 
                let style = `background:${config.categoricalMap[value]}`;
                if (config.pointLayer) {
                     style += `; border-radius: 50%;`;
                }
                labels.push(`<i style="${style}"></i> ${value}`); 
            } 
            content = labels.join('<br>'); 
        } 
        this._div.innerHTML = content; 
    };
    legendControl.addTo(map);
    
    function applyLayerOrder() { orderedLayers.forEach(layer => layer.bringToFront()); }
    
    map.on('overlayadd', e => { const index = orderedLayers.findIndex(l => L.stamp(l) === L.stamp(e.layer)); if (index === -1) { orderedLayers.unshift(e.layer); } if (!currentActiveLayer) { currentActiveLayer = e.layer; } applyLayerOrder(); infoControl.update(); legendControl.update(currentActiveLayer); });
    map.on('overlayremove', e => { const layerIdToRemove = L.stamp(e.layer); orderedLayers = orderedLayers.filter(layer => L.stamp(layer) !== layerIdToRemove); if (e.layer === currentActiveLayer) { currentActiveLayer = orderedLayers.length > 0 ? orderedLayers[0] : null; } infoControl.update(); legendControl.update(currentActiveLayer); });
    
    function handleUploadedFile(file) {
        if (!file) return;
        const extension = file.name.split('.').pop().toLowerCase();
        const reader = new FileReader();

        const loadingMessage = L.DomUtil.create('div', 'loading-indicator', map.getContainer());
        loadingMessage.innerText = `Cargando ${file.name}...`;

        reader.onload = function(event) {
            try {
                if (extension === 'zip') {
                    shp(event.target.result).then(function(geojson){
                        if (Array.isArray(geojson)) {
                            geojson.forEach(featureCollection => {
                                processData(featureCollection, featureCollection.name || file.name);
                            });
                        } else {
                            processData(geojson, file.name);
                        }
                        map.getContainer().removeChild(loadingMessage);
                    }).catch(err => {
                        alert("Error procesando Shapefile: " + err.message);
                        map.getContainer().removeChild(loadingMessage);
                    });
                } else if (extension === 'geojson' || extension === 'json') {
                    processData(JSON.parse(event.target.result), file.name);
                    map.getContainer().removeChild(loadingMessage);
                }
            } catch (err) {
                alert("Error procesando el archivo: " + err.message);
                map.getContainer().removeChild(loadingMessage);
            }
        };
        reader.onerror = function() {
            alert("Error al leer el archivo.");
            map.getContainer().removeChild(loadingMessage);
        };

        if (extension === 'zip') {
            reader.readAsArrayBuffer(file);
        } else {
            reader.readAsText(file);
        }
    }
    
    L.Control.Custom = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-control');
            container.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Cargar Archivo</title><path d="M19.35,10.04C18.67,6.59 15.64,4 12,4C9.11,4 6.6,5.64 5.35,8.04C2.34,8.36 0,10.91 0,14A6,6 0 0,0 6,20H19A5,5 0 0,0 24,15C24,12.36 21.95,10.22 19.35,10.04M19,18H6A4,4 0 0,1 2,14C2,11.95 3.53,10.24 5.56,10.03L6.63,9.92L7.13,8.97C8.08,7.14 9.94,6 12,6C14.62,6 16.88,7.86 17.39,10.43L17.69,11.93L19.22,12.04C20.78,12.14 22,13.45 22,15A3,3 0 0,1 19,18M8,13H10.55V17H13.45V13H16L12,9L8,13Z" /></svg>';
            container.title = 'Cargar Archivo(s)';
            
            const fileInput = L.DomUtil.create('input');
            fileInput.type = 'file';
            fileInput.accept = ".geojson,.json,.zip";
            fileInput.multiple = true;
            fileInput.style.display = 'none';
            
            container.appendChild(fileInput);

            fileInput.onchange = (e) => { 
                if (!e.target.files) return; 
                for (const file of e.target.files) { 
                    handleUploadedFile(file); 
                } 
                e.target.value = '';
            };
            
            L.DomEvent.disableClickPropagation(container);
            L.DomEvent.on(container, 'click', function() {
                fileInput.click();
            });

            return container;
        }
    });
    new L.Control.Custom({ position: 'topleft' }).addTo(map);

    function exportMap() {
        const controlsToHide = document.querySelectorAll(
            '.leaflet-control-container > .leaflet-top, ' +
            '.leaflet-control-container > .leaflet-bottom-left, ' +
            '.info.leaflet-control'
        );
        controlsToHide.forEach(el => el.classList.add('hide-for-export'));

        leafletImage(map, function(err, canvas) {
            controlsToHide.forEach(el => el.classList.remove('hide-for-export'));
            if (err) {
                console.error("Error al exportar el mapa con leaflet-image:", err);
                alert("Hubo un error al exportar el mapa. Por favor, inténtelo de nuevo.");
            } else {
                const link = document.createElement('a');
                link.download = 'mapa_exportado.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
        });
    }

    L.Control.Export = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-control');
            container.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Exportar Imagen</title><path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" /></svg>';
            container.title = 'Exportar Imagen';
            L.DomEvent.on(container, 'click', function(e) { L.DomEvent.stopPropagation(e); exportMap(); });
            return container;
        }
    });
    new L.Control.Export({ position: 'topleft' }).addTo(map);

    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
        edit: {
            featureGroup: drawnItems,
            remove: true
        },
        draw: {
            polygon: {
                allowIntersection: false,
                showArea: true
            },
            polyline: true,
            rectangle: true,
            circle: false,
            marker: false
        }
    });
    map.addControl(drawControl);

    map.on(L.Draw.Event.CREATED, function (e) {
        const layer = e.layer;
        const type = e.layerType;
        let content = '';

        if (type === 'polyline') {
            let distance = 0;
            const latlngs = layer.getLatLngs();
            for (let i = 0; i < latlngs.length - 1; i++) {
                distance += latlngs[i].distanceTo(latlngs[i+1]);
            }
            content = `Distancia: ${ (distance / 1000).toFixed(2) } km`;
        } else if (type === 'polygon' || type === 'rectangle') {
            const area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
            content = `Área: ${ (area / 10000).toFixed(2) } hectáreas`;
        }
        
        if (content) {
            layer.bindPopup(content).openPopup();
        }
        
        drawnItems.addLayer(layer);
        
        drawnItemsHistory.push(layer); 
    });

    function undoLastDrawAction() {
        if (drawnItemsHistory.length > 0) {
            const lastDrawnLayer = drawnItemsHistory.pop();
            if (drawnItems.hasLayer(lastDrawnLayer)) {
                drawnItems.removeLayer(lastDrawnLayer);
            }
        }
    }

    document.addEventListener('keydown', function(event) {
        const isCtrlOrCmdZ = (event.ctrlKey || event.metaKey) && event.key === 'z';
        const isInputTarget = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';

        if (isCtrlOrCmdZ && !isInputTarget) {
            event.preventDefault();
            undoLastDrawAction();
        }
    });

</script>
</body>
</html>
